// Copyright (c) 2019 IBM Corporation and others.
// Licensed under Creative Commons Attribution-NoDerivatives
// 4.0 International (CC BY-ND 4.0)
//   https://creativecommons.org/licenses/by-nd/4.0/
//
// Contributors:
//   IBM Corporation
:projectid: microprofile-rest-client-async
:page-layout: guide-multipane
:page-duration: 15 minutes
:page-releasedate: 2019-09-13
:page-guide-category: microprofile
:page-essential: false
:page-description: Learn how to use MicroProfile Rest Client to invoke RESTful microservices asynchronously over HTTP.
:page-seo-title: Consuming RESTful Java microservices asynchronously using Eclipse MicroProfile Rest Client
:page-seo-description: A getting started tutorial and an example on how to consume RESTful Java microservices with asynchronous method calls using the CompletionStage interface and MicroProfile Rest Client.
:guide-author: Open Liberty
:page-tags: ['MicroProfile']
:page-permalink: /guides/{projectid}
:page-related-guides: ['microprofile-rest-client']
:common-includes: https://raw.githubusercontent.com/OpenLiberty/guides-common/master
:imagesdir: /img/guide/{projectid}
:source-highlighter: prettify
:mac: MAC
:win: WINDOWS
:linux: LINUX
= Consuming RESTful services asynchronously with template interfaces

[.hidden]
NOTE: This repository contains the guide documentation source. To view the guide in published form, view it on the https://openliberty.io/guides/{projectid}.html[Open Liberty website].

Learn how to use MicroProfile Rest Client to invoke RESTful microservices asynchronously over HTTP.

== What you'll learn

You will learn how to build a MicroProfile Rest Client to access remote RESTful services using asynchronous method calls.
You'll update the template interface for a MicroProfile Rest Client, which maps to the remote service that you want to call,
to use the `CompletionStage` return type. A `CompletionStage` interface allows you to work with the result of your remote
service call asynchronously.

*What is asynchronous programming?* +
Imagine asynchronous programming as a restaurant. After you're seated, the waitstaff takes your order.
Then, you must wait a few minutes for your food to be prepared. While your food is being prepared,
the waitstaff may take more orders or serve other tables. After your food is ready, the waitstaff brings out the food to your table.
However, in a synchronous model, the waitstaff must wait for your food to be prepared before serving any other customers.
This method blocks other customers from placing orders or receiving their food.

You can perform lengthy operations, such as input/output (I/O), without blocking with asynchronous methods.
The I/O operation can occur in the background and a callback notifies the caller to continue its computation
when the original request is complete. As a result, the original thread frees up so it can handle other work
rather than wait for the I/O to complete. Revisiting the restaurant analogy, food is prepared asynchronously in
the kitchen and the waitstaff is freed up to attend to other tables.

In the context of REST clients, HTTP request calls can be time consuming.
The network might be slow, or maybe the upstream service is overwhelmed and can't respond quickly.
These lengthy operations can block the execution of your thread when it's in use and prevent other work from being completed.

The OpenLiberty Cafe application is designed with reactive architecture.
The application that you'll be working with consists of six microservices:
`Bar`, `Kitchen`, `Order`, `OpenLibertyCafe`, `ServingWindow`, and `Status`.
It also uses Kafka to enable reactive messaging communication between the Producer and Consumer microservices over the messaging channels.
If you want to learn more about reactive messaging,
you can read the https://openliberty.io/guides/microprofile-reactive-messaging.html[Creating asynchronous reactive microservices using MicroProfile Reactive Messaging^] guide.

image::reactive-messaging-restaurant.png[Reactive restaurant,align="center"]

The microservice that you will modify is the `OpenLibertyCafe` service.
The `OpenLibertyCafe` microservice is a
https://microservices.io/patterns/apigateway.html#variation-backends-for-frontends[backends for frontends^] service.
It communicates with the backend microservices on the caller's behalf.

The waitstaff places a request using the `OpenLibertyCafe` microservice.

The `Order` microservice consumes the request, produces order messages, and sends them to Kafka on the
`food` or `beverage`channel depending on the type.

An order begins with a `NEW` status. The `Bar` and `Kitchen` microservices illustrate how to handle the orders as a real cafe.
They consume and process the order and update the status to `IN_PROGRESS` and `READY` consecutively.
Thereâ€™s a sleep operation in between each status to represent the order processing time, and the status updates are reported
back to the `Status` microservice via reactive messages on the Kafka.

The `ServingWindow` microservice illustrates when the food and beverages are ready to be served.
It consumes the `READY` order from the `Kitchen` and `Bar` microservices.
Once the order is served, the waitstaff can mark the order as `COMPLETED` and the status is sent back to the `Status` microservice as a message.

The `Status` microservice receives status updates and provides queries for the waitstaff.
All the orders are persisted here. Because persisting data is not the focus of this guide,
the `Status` microservice simply uses a Map object to store the data.

If you want to learn more about MicroProfile Rest Client,
you can read the https://openliberty.io/guides/microprofile-rest-client.html[Consuming RESTful services with template interfaces^] guide.


// =================================================================================================
// Prerequisites
// =================================================================================================
== Additional prerequisites

You will build and run the microservices in Docker containers. 
You can learn more about containerizing microservices with Docker in the https://openliberty.io/guides/containerize.html[Containerizing microservices^] guide.

Install Docker by following the instructions on the official https://docs.docker.com/engine/installation[Docker documentation^]. 
Start your Docker environment.

// =================================================================================================
// Getting started
// =================================================================================================

[role='command']
include::{common-includes}/gitclone.adoc[]

// =================================================================================================
// Sending order requests synchronously
// =================================================================================================

== Sending order requests synchronously

Navigate to the `start` directory to begin.

The synchronous implementation of the application is provided for you in the `start` directory.

You will place food and beverage orders and observe that the order requests are processed in the same sequence that they are
sent to the `Order` service through the REST client.

=== Running the synchronous application

You will build and run the `OpenLibertyCafe`, `Order`, `Bar`, `Kitchen`, `ServingWindow`, and `Status` microservices in Docker containers. 

To build the application, run the Maven `install` and `package` goals from the command line in the `start` directory:

[role='command']
```
mvn -pl models install
mvn package
```

Run the following command to download or update the `open-liberty` Docker image to the latest.
[role='command']
```
docker pull open-liberty
```

Run the following commands to containerize the microservices:

[role='command']
```
docker build -t openlibertycafe:1.0-SNAPSHOT openLibertyCafe/.
docker build -t order:1.0-SNAPSHOT order/.
docker build -t bar:1.0-SNAPSHOT bar/.
docker build -t kitchen:1.0-SNAPSHOT kitchen/.
docker build -t servingwindow:1.0-SNAPSHOT servingWindow/.
docker build -t status:1.0-SNAPSHOT status/.
```

Next, use the provided script to start the application in Docker containers. 
The script creates a network for the containers to communicate with each other. 
It also creates containers for Kafka, Zookeeper, and all of the microservices in the project.

include::{common-includes}/os-tabs.adoc[]

[.tab_content.mac_section.linux_section]
--
[role='command']
```
./scripts/startContainers.sh
```
--

[.tab_content.windows_section]
--
[role='command']
```
.\scripts\startContainers.bat
```
--

The services take some time to become available.

Once the application is up and running, you can access the application by making requests to the `OpenLibertyCafe` endpoint using OpenAPI.
Check out the service that you created at the http://localhost:9080/openapi/ui[^] URL.

Place food and beverage orders by making a `POST` request to the `/api/orders` endpoint.
To make this request, expand the `POST` endpoint on the UI, click the *Try it out button*.
Copy the following example input into the text box, and then click the `Execute` button.

[source, role='command']
----
{
  "tableId": "1",
  "foodList": [
    "f1",
    "f2",
    "f3",
    "f4",
    "f5"
  ],
  "beverageList": [
    "b1",
    "b2",
    "b3",
    "b4",
    "b5"
  ]
}
----

Each food and beverage order is given an order ID.
The [hotspot fiile=0]`OpenLibertyCafeOrderResource.java` class iterates through each food and beverage in the
[hotspot=loopFoodList file=0]`foodList` and [hotspot=loopBeverageList file=0]`beverageList` and [hotspot=add1 hotspot=add2 fil=0]`adds`
the order ID for each order into the list [hotspot=orderIDs]`orderIds`. The order IDs are listed 
in the sequence in which they were processed, starting from the first food order to the last beverage order.

The `POST` request adds new `food` and `beverage` orders, and returns the list [hotspot=orderIDs]`orderIds`:

[source, role="no_copy"]
----
[
  "0001",
  "0002",
  "0003",
  "0004",
  "0005",
  "0006",
  "0007",
  "0008",
  "0009",
  "0010"
]
----

OpenLibertyCafeOrderResource.java
[source, Java, linenums, role='code_column hide_tags=copyright']
----
include::start/openLibertyCafe/src/main/java/io/openliberty/guides/openlibertycafe/OpenLibertyCafeOrderResource.java[]
----

In this synchronous approach, order requests are blocked until the previous order request is completed.
So, the returned order IDs are in numerical order.

Later, you will update the application to place order requests asynchronously.

// =================================================================================================
// Updating the template interface of a REST client to use asynchronous methods
// =================================================================================================

== Updating the template interface of a REST client to use asynchronous methods

Navigate to the `start` directory to begin.

OrderClient.java
[source, Java, linenums, role='code_column hide_tags=copyright']
----
include::start/openLibertyCafe/src/main/java/io/openliberty/guides/openlibertycafe/client/OrderClient.java[]
----

The `OpenLibertyCafe` service uses a MicroProfile Rest Client to access the `Order` service.
You will update the [hotspot=createOrder file=0]`createOrder` method in the template interface for this client to be asynchronous.

[role="code_command hotspot file=1", subs="quotes"]
----
#Replace the `OrderClient` interface.#
`openLibertyCafe/src/main/java/io/openliberty/guides/openlibertycafe/client/OrderClient.java`
----
OrderClient.java
[source, Java, linenums, role='code_column hide_tags=copyright']
----
include::finish/openLibertyCafe/src/main/java/io/openliberty/guides/openlibertycafe/client/OrderClient.java[]
----

Add the [hotspot=async file=1]`@Asynchronous` annotation to the [hotspot=createOrder file=1]`createOrder` method.
When a method marked with the `@Asynchronous` annotation is called from one thread, the method call is
intercepted, and execution of the method is submitted to run asynchronously on another thread.
A method annotated with the `@Asynchronous` annotation must return either a `CompletionStage` type or `Future` type
from the `java.util.concurrent` package.

The [hotspot=createOrder file=1]`createOrder` method now returns a [hotspot=createOrder file=1]`CompletionStage<Response>` type
instead of a `Response` type.

Since the method now has return type of `CompletionStage<Response>`, you aren't able to directly manipulate the inner type. 
As you will see in the next section, you will be able to indirectly use the inner object by chaining callbacks.

// =================================================================================================
// Updating a REST resource to asynchronously handle HTTP requests
// =================================================================================================

== Updating a REST resource to asynchronously handle HTTP requests

JAX-RS resources can also have asynchronous methods. So instead of returning a `Response` type, 
you can return a `CompletionStage<Respone>` type. Completion stages can be chained together by using the 
[hotspot=thenAcceptAsync1 hotspot=thenAcceptAsync2 file=0]`thenAcceptAsync()` method.

[role="code_command hotspot", subs="quotes"]
----
#Replace the `OpenLibertyCafeOrderResource` class.#
`openLibertyCafe/src/main/java/io/openliberty/guides/openlibertycafe/OpenLibertyCafeOrderResource.java`
----
OpenLibertyCafeOrderResource.java
[source, Java, linenums, role='code_column hide_tags=copyright']
----
include::finish/openLibertyCafe/src/main/java/io/openliberty/guides/openlibertycafe/OpenLibertyCafeOrderResource.java[]
----

Similar to the synchronous approach, if completed orders are successfully obtained from the `Order` microservice, 
the resource responds with an HTTP status of 200 and the body will contain a list of order IDs. 
However, the order requests are not blocked and do not wait for other requests to complete.

The `CompletionStage` interface represents a unit of computation. After that computation completes, it can either be finished or chained 
with more completion stages by using the `thenAcceptAsync()` method to perform more computations.
The `thenAcceptAsync()` method accepts and consumes the result of the previous `CompletionStage`.

The returned `CompletionStage<Response>` from the
[hotspot=thenAcceptAsync1 hotspot=thenAcceptAsync2 file=0]`orderClient.createOrder(order)` method is consumed asynchronously by the 
[hotspot=thenAcceptAsync1 hotspot=thenAcceptAsync2 file=0]`thenAcceptAsync()` method and adds processed order IDs to a list.

// =================================================================================================
// Building and running the application
// =================================================================================================

== Building and running the application

To build your asynchronous application, run the Maven `install` and `package` goals again:

[role='command']
```
mvn -pl models install
mvn package
```

Run the following commands to containerize the microservices:

[role='command']
```
docker build -t openlibertycafe:1.0-SNAPSHOT openLibertyCafe/.
docker build -t order:1.0-SNAPSHOT order/.
docker build -t bar:1.0-SNAPSHOT bar/.
docker build -t kitchen:1.0-SNAPSHOT kitchen/.
docker build -t servingwindow:1.0-SNAPSHOT servingWindow/.
docker build -t status:1.0-SNAPSHOT status/.
```

Next, use the provided script to start the application in Docker containers.

include::{common-includes}/os-tabs.adoc[]

[.tab_content.mac_section.linux_section]
--
[role='command']
```
./scripts/startContainers.sh
```
--

[.tab_content.windows_section]
--
[role='command']
```
.\scripts\startContainers.bat
```
--

The services take some time to become available.
Check out the service that you created at the http://localhost:9080/openapi/ui[^] URL.

Place food and beverage orders by making a `POST` request to the `/api/orders` endpoint.
To make this request, expand the `POST` endpoint on the UI, click the *Try it out button*.
Copy the following example input into the text box, and then click the `Execute` button.

[source, role='command']
----
{
  "tableId": "1",
  "foodList": [
    "f1",
    "f2",
    "f3",
    "f4",
    "f5"
  ],
  "beverageList": [
    "b1",
    "b2",
    "b3",
    "b4",
    "b5"
  ]
}
----

The order requests are processed asynchronously and do not wait for other requests to be completed.
The returned order IDs are listed in the sequence in which they were processed, which will not be in numerical order.

[source, role="no_copy"]
----
[
  "0005",
  "0008",
  "0004",
  "0003",
  "0010",
  "0006",
  "0001",
  "0002",
  "0009",
  "0007"
]
----

Switching to an asynchronous programming model freed up the thread that was handling your request to `/api/orders`. 
While the request is processed, the thread can handle other work.

== Tearing down the environment

Finally, use the following script to stop the application:

include::{common-includes}/os-tabs.adoc[]

[.tab_content.mac_section.linux_section]
--
[role='command']
```
./scripts/stopContainers.sh
```
--

[.tab_content.windows_section]
--
[role='command']
```
.\scripts\stopContainers.bat
```
--

== Great work! You're done!

You have just modified an application to make asynchronous HTTP requests using Open Liberty and MicroProfile Rest Client.

include::{common-includes}/attribution.adoc[subs="attributes"]
