// Copyright (c) 2019 IBM Corporation and others.
// Licensed under Creative Commons Attribution-NoDerivatives
// 4.0 International (CC BY-ND 4.0)
//   https://creativecommons.org/licenses/by-nd/4.0/
//
// Contributors:
//   IBM Corporation
:projectid: microprofile-rest-client-async
:page-layout: guide-multipane
:page-duration: 15 minutes
:page-releasedate: 2019-09-13
:page-guide-category: microprofile
:page-essential: false
:page-description: Learn how to use MicroProfile Rest Client to invoke RESTful microservices asynchronously over HTTP.
:page-seo-title: Consuming RESTful Java microservices asynchronously using Eclipse MicroProfile Rest Client
:page-seo-description: A getting started tutorial and an example on how to consume RESTful Java microservices with asynchronous method calls using the CompletionStage interface and MicroProfile Rest Client.
:guide-author: Open Liberty
:page-tags: ['MicroProfile']
:page-permalink: /guides/{projectid}
:page-related-guides: ['microprofile-rest-client']
:common-includes: https://raw.githubusercontent.com/OpenLiberty/guides-common/master
:imagesdir: /img/guide/{projectid}
:source-highlighter: prettify
:mac: MAC
:win: WINDOWS
:linux: LINUX
= Consuming RESTful services asynchronously with template interfaces

[.hidden]
NOTE: This repository contains the guide documentation source. To view the guide in published form, view it on the https://openliberty.io/guides/{projectid}.html[Open Liberty website].

Learn how to use MicroProfile Rest Client to invoke RESTful microservices asynchronously over HTTP.

== What you'll learn

You will learn how to build a MicroProfile Rest Client to access remote RESTful services using asynchronous method calls. 
You'll update the template interface for a MicroProfile Rest Client, which maps to the remote service that you want to call, to use the `CompletionStage` return type. 
A `CompletionStage` interface allows you to work with the result of your remote service call asynchronously.

*What is asynchronous programming?* +
Imagine asynchronous programming as a restaurant. 
After you're seated, a waiter takes your order. 
Then, you must wait a few minutes for your food to be prepared. 
While your food is being prepared, your waiter may take more orders or serve other tables. 
After your food is ready, your waiter brings out the food to your table. However, in a synchronous model, the waiter must wait for your food to be prepared before serving any other customers. 
This method blocks other customers from placing orders or receiving their food.

You can perform lengthy operations, such as input/output (I/O), without blocking with asynchronous methods. 
The I/O operation can occur in the background and a callback notifies the caller to continue its computation when the original request is complete. 
As a result, the original thread frees up so it can handle other work rather than wait for the I/O to complete. 
Revisiting the restaurant analogy, food is prepared asynchronously in the kitchen and your waiter is freed up to attend to other tables.

In the context of REST clients, HTTP request calls can be time consuming. 
The network might be slow, or maybe the upstream service is overwhelmed and can't respond quickly. 
These lengthy operations can block the execution of your thread when it's in use and prevent other work from being completed.

The application that you'll be working with is a system manager that maintains an inventory of available systems.
It consists of three microservices, `query`, `inventory`, and `system`. 

The `system` microservice records system information such as the system load.
The `system` microservice registers itself at startup with the `inventory` microservice which keeps track of all instances of the `system` microservice. 
Finally,the `query` microservice is a https://microservices.io/patterns/apigateway.html#variation-backends-for-frontends[backend for frontend^] service.
It communicates with the backend `inventory` microservice on the caller's behalf.

image::reactive-inventory-system.png[Reactive Inventory System,align="center"]

The microservice that you will modify is the `query` service.
It acts as a middleman to communicate with the backend microservices.
Whenever a request is made to the `query` service to retrieve the inventory,
the `query` service communicates with the `inventory`service to get system information.

The implementations of the application and its services are provided for you in the `start/src` directory.
The application also uses the Apache Kafka and ZooKeeper services to distribute the system status.

If you want to learn more about MicroProfile Rest Client, you can read the https://openliberty.io/guides/microprofile-rest-client.html[Consuming RESTful services with template interfaces^] guide.


// =================================================================================================
// Getting started
// =================================================================================================

[role='command']
include::{common-includes}/gitclone.adoc[]

== Updating the template interface of a REST client to use asynchronous methods

Navigate to the `start` directory to begin.

The `query` service uses a MicroProfile Rest Client to access the `inventory` service.
You will update the methods in the template interface for this client to be asynchronous.

[role="code_command hotspot", subs="quotes"]
----
#Replace the `InventoryClient` interface.#
`query/src/main/java/io/openliberty/guides/query/client/InventoryClient.java`
----

InventoryClient.java
[source, java, linenums, role='code_column hide_tags=copyright']
----
include::finish/query/src/main/java/io/openliberty/guides/query/client/InventoryClient.java[]
----

The changes involve the [hotspot=getSystem file=0]`getSystem` method. 
Change the return type to `CompletionStage<Properties>` and add the annotation `@Asynchronous`.
These changes make the method asynchronous.
Since the method now has the return type of `CompletionStage<Properties>`, you aren't able to directly manipulate the inner `Properties`. 
As you will see in the next section, you will be able to indirectly use the `Properties` by chaining callbacks.

== Updating a REST resource to asynchronously handle HTTP requests

JAX-RS resources can also have asynchronous methods. So instead of returning a `Properties` type, you can return a `CompletionStage<Properties>` type. 
Completion stages can be chained together by using the [hotspot=thenAcceptAsync file=0]`thenAcceptAsync()` method.

[role="code_command hotspot", subs="quotes"]
----
#Replace the `QueryResource` class.#
`query/src/main/java/io/openliberty/guides/query/QueryResource.java`
----

QueryResource.java
[source, java, linenums, role='code_column hide_tags=copyright']
----
include::finish/query/src/main/java/io/openliberty/guides/query/QueryResource.java[]
----

The `CompletionStage` interface represents a unit of computation.
After a computation is complete, it can be either finished or chained with more completion stages using the [hotspot=thenAcceptAsync file=0]`thenAcceptAsync()` method. 
Exceptions are handled in a callback provided to the [hotspot=exceptionally file=0]`exceptionally()` method, which behaves similar to a catch block.
When you return a `CompletionStage` type in the resource, it doesnâ€™t necessarily mean that the computation completed and the response was built.
JAX-RS will respond to the caller after the `CompletionStage` completes.

A [hotspot=countdown1 hotspot=countdown2 hotspot=countdown3 file=0]`CountDownLatch` is used to keep track of how many asynchronous requests we are waiting on.
Using the [hotspot=await file=0]`await` method, we stop and wait until all our requests are complete. 

The keyword [hotspot=volatile file=0]`volatile` and the type [hotspot=concurrentHashMap file=0]`ConcurrentHashMap` are used to store the system information.
Together these allow us to store system information and have it safely accessed asynchronously by multiple threads. 

// =================================================================================================
// Building the application
// =================================================================================================

== Building and running the application

You will build and run the `query`, `system`, and `inventory` microservices in Docker containers. 
You can learn more about containerizing microservices with Docker in the https://openliberty.io/guides/containerize.html[Containerizing microservices^] guide.

Install Docker by following the instructions on the official https://docs.docker.com/engine/installation[Docker documentation^]. Start your Docker environment.

To build the application, run the provided `packageApps` script:

include::{common-includes}/os-tabs.adoc[]

[.tab_content.windows_section]
--
[role='command']
```
.\scripts\packageApps.bat
```
--

[.tab_content.mac_section.linux_section]
--
[role='command']
```
./scripts/packageApps.sh
```
--

Build your Docker images using the provided `buildImages` script:

include::{common-includes}/os-tabs.adoc[]

[.tab_content.windows_section]
--
[role='command']
```
.\scripts\buildImages.bat
```
--

[.tab_content.mac_section.linux_section]
--
[role='command']
```
./scripts/buildImages.sh
```
--

Next, use the provided `startContainers` script to start the application in Docker containers. 
The script creates a network for the containers to communicate with each other. 
It also creates containers for Kafka, Zookeeper, and all of the microservices in the project.
The script also creates three instances of the `system` microservice. 

include::{common-includes}/os-tabs.adoc[]

[.tab_content.mac_section.linux_section]
--
[role='command']
```
./scripts/startContainers.sh
```
--

[.tab_content.windows_section]
--
[role='command']
```
.\scripts\startContainers.bat
```
--

The services take some time to become available.
Access the application by using `curl` commands as follows:

[role='command']
```
curl -X GET localhost:9080/query/systemLoad
```

If `curl` is not available, the Postman application can also be used.
The output will be similar to the following. The given example has been formatted for readability. 

[source, role='no_copy']
----
{
    "highest": {
        "hostname" : "8841bd7d6fcd",
        "systemLoad" : 6.96
    },
    "lowest": {
        "hostname" : "37140ec44c9b",
        "systemLoad" : 6.4
    }
}
----

Switching to an asynchronous programming model freed up the thread that handles requests to the inventory service. 
While requests process, the thread can handle other work or requests.
In the [hotspot=systemLoad file=0]`/query/systemLoad` endpoint multiple systems are read and compared at once.

// =================================================================================================
// Testing
// =================================================================================================

== Testing the query application

You will create an endpoint test to test the basic functionality of the `query` microservice. 
If a test failure occurs, then you may have introduced a bug into the code.

[role="code_command hotspot", subs="quotes"]
----
#Create the `QueryServiceIT` class.#
`query/src/test/java/it/io/openliberty/guides/query/QueryServiceIT.java`
----

The [hotspot=testLoads file=0]`testLoads()` test case verifies that the `query` service can calculate the highest and lowest system loads. 

QueryServiceIT.java
[source, java, linenums, role='code_column hide_tags=copyright,javadoc']
----
include::finish/query/src/test/java/it/io/openliberty/guides/query/QueryServiceIT.java[]
----

// =================================================================================================
// Running the tests
// =================================================================================================

=== Running the tests

Navigate to the `query` directory, then verify that the tests pass by using the Maven `verify` goal:

[role='command']
```
mvn verify
```

When the tests succeed, you see output similar to the following example:

[source, role='no_copy']
----
-------------------------------------------------------
 T E S T S
-------------------------------------------------------
Running it.io.openliberty.guides.query.QueryServiceIT
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 32.123 s - in it.io.openliberty.guides.query.QueryServiceIT

Results:

Tests run: 1, Failures: 0, Errors: 0, Skipped: 0
----

== Tearing down the environment

Navigate back to the `start` directory.

Finally, use the `stopContainers` script to stop the application:

include::{common-includes}/os-tabs.adoc[]

[.tab_content.mac_section.linux_section]
--
[role='command']
```
./scripts/stopContainers.sh
```
--

[.tab_content.windows_section]
--
[role='command']
```
.\scripts\stopContainers.bat
```
--

== Great work! You're done!

You have just modified an application to make asynchronous HTTP requests using Open Liberty and MicroProfile Rest Client.

include::{common-includes}/attribution.adoc[subs="attributes"]
